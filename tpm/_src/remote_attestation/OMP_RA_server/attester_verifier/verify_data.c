#include <stdio.h>

#include <openssl/rsa.h>
#include <openssl/evp.h>
#include <openssl/x509.h>

#include "verify_data.h"
#include "dbg_macros.h"
#include "ra_com.h"
#include "ra_server.h"

/**
 * @brief verify attestant's response nonce
 * @return SUCCESS on success, FAILED otherwize
 * @param pcrComposite attestant's response 
 * @param nonce generated by attester 
*/
/********************************************************************
PCR Composite 데이터 구조 - (Version Info False)

00 36 // TPM Structure tag
51 55 54 32 // Magic info (ascii:QUT2)
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 00 // nonce[20]
00 03 // PCR selection num
06 00 00 // PCR selection (pcr1, pcr2)
01 //TPM Locality Selection
27 E0 07 6B AC 89 0C 09 60 7E 8C 93 87 D5 00 25 1A 22 08 F5 // pcr composite hash[20]
**********************************************************************/
int verify_pcr_nonce(unsigned char * pcrComposite, BYTE* nonce)
{
	if(dbg_lv == DDBG){
#ifdef TPM1_1 // TPM 1.1
		print_hex_block((char *)pcrComposite+28,20, "Verify>> PCR Composite NONCE");
#else // TPM 1.2
		print_hex_block((char *)pcrComposite+QUOTE2_COMPOSITE_IDX_NONCE, NONCE_LEN, "Verify>> PCR Composite NONCE");
		print_hex_block((char *)nonce, NONCE_LEN, "Verify>> NONCE");
#endif
	}

#ifdef TPM1_1 // TPM 1.1
	if(!memcmp(nonce, pcrComposite + 28, 20))
#else
	if(!memcmp(nonce, pcrComposite+QUOTE2_COMPOSITE_IDX_NONCE, NONCE_LEN))
#endif
	{
		print_result_block(DINFO,"Verify>> NONCE Matched");
		return SUCCESS;
	}
	else {
		print_result_block(DINFO, "Verify>> NONCE NOT Matched");
		return FAILED;
	}

}

/**
 * @brief verify attestant's response digest 
 * @return SUCCESS on success, FAILED otherwize
 * @param pcrComposite attestant's response 
 * @param pcrAnswer match with attestant's response 
*/
int verify_pcr_digest(unsigned char * pcrComposite, unsigned char *pcrAnswer){
	if(dbg_lv == DDBG){
		print_hex_block((char *)pcrComposite + QUOTE2_COMPOSITE_IDX_PCR_DIGEST, 20, "Verify>> PCR digest");

		print_hex_block((char *)pcrAnswer, 20, "Verify>> PCR answer");
	}

#ifdef TPM1_1 // TPM 1.1
	if(!memcmp(pcrAnswer, pcrComposite+8, PCR_DIGEST_LEN))
#else // TPM 1.2
	if(!memcmp(pcrAnswer, pcrComposite + QUOTE2_COMPOSITE_IDX_PCR_DIGEST, PCR_DIGEST_LEN))
//	if(!memcmp(pcr_digest, pcrComposite + QUOTE2_COMPOSITE_IDX_PCR_DIGEST, PCR_DIGEST_LEN))
#endif
	{
		print_result_block(DINFO, "Verify>> PCR Digest Matched");
		return SUCCESS;
	}
	else {
		print_result_block(DINFO, "Verify>> PCR Digest NOT Matched");
		return FAILED;
	}
}

/**
 * @brief verify attestant's response with AIK pubkey 
 * @return SUCCESS on success, FAILED otherwize
 * @param pcrComposite attestant's response 
 * @param pcrCompositeSize attestant's composite len 
 * @param keyPub AIK Public key from attestant
 * @param keyPubSize AIK Public Key size 
 * @param signedPCR signed PCR by attestant  
 * @param signedPCRSize signed PCR size 
*/
int verify_pcr_composite(unsigned char * pcrComposite, int pcrCompositeSize, unsigned char *keyPub, int keyPubSize, unsigned char * signedPCR, int signedPCRSize){
	int result;
	unsigned char exp[] = {0x01, 0x00, 0x01};
	unsigned char sha1PCRComposite[20];
	SHA_CTX b;

	SHA1_Init(&b);
	SHA1_Update(&b, pcrComposite, pcrCompositeSize);
	SHA1_Final(sha1PCRComposite, &b);
	
	RSA *rsa = RSA_new();
	if(rsa == NULL) {
		dbg_printf(DERROR, "===== Generate The RSA key error =====\n");
		return FAILED;
	}
	
	rsa->n = BN_bin2bn(keyPub, keyPubSize, rsa->n);
	rsa->e = BN_bin2bn(exp, sizeof(exp), rsa->e);
	
	if((rsa->n == NULL) || (rsa->e == NULL)) {
		dbg_printf(DERROR, "===== Assign RSA key error =====\n");
		RSA_free(rsa);
		return FAILED;
	}
		
	dbg_printf(DINFO, "Verify SHA1(TCPA_QUOTE_INFO) signature...\n");
	result = RSA_verify(NID_sha1, sha1PCRComposite, SHA_DIGEST_LENGTH, signedPCR, signedPCRSize, rsa);
	RSA_free(rsa);

	if(result == 0) {
		print_result_block(DINFO, "Verify>> PCR Signature NOT Verified");
		return FAILED;
	}
	else{
		print_result_block(DINFO, "Verify>> PCR Signature Verified");
		return SUCCESS;
	}
}
